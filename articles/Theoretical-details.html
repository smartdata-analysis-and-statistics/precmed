<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Theoretical details • precmed</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Theoretical details">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">precmed</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html"><span class="fa fa-home fa-lg"></span></a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-vignettes" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Vignettes</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-vignettes">
<li><a class="dropdown-item" href="../articles/Count-examples.html">Example with count outcome</a></li>
    <li><a class="dropdown-item" href="../articles/Survival-examples.html">Example with survival outcome</a></li>
    <li><a class="dropdown-item" href="../articles/Additional-examples.html">Additional examples</a></li>
    <li><a class="dropdown-item" href="../articles/Theoretical-details.html">Theoretical details</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Functions</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">News</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/smartdata-analysis-and-statistics/precmed"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Theoretical details</h1>
            <h3 data-toc-skip class="subtitle">Vignette 4 of 4</h3>
            
            <h4 data-toc-skip class="date">October 05, 2024</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/smartdata-analysis-and-statistics/precmed/blob/v1.1.0/vignettes/Theoretical-details.Rmd" class="external-link"><code>vignettes/Theoretical-details.Rmd</code></a></small>
      <div class="d-none name"><code>Theoretical-details.Rmd</code></div>
    </div>

    
    
<!-- badges: start -->
<p><a href="https://cran.r-project.org/package=precmed" class="external-link"><img src="https://www.r-pkg.org/badges/version/precmed" alt="CRAN_Status_Badge"></a> <a href="https://cran.r-project.org/package=precmed" class="external-link"><img src="https://cranlogs.r-pkg.org/badges/last-month/precmed" alt="metacran downloads"></a> <!-- badges: end --></p>
<h1>
precmed: Precision Medicine in R
</h1>
<p>A doubly robust precision medicine approach to estimate and validate
conditional average treatment effects</p>
<div class="section level2">
<h2 id="theoretical-details---count-outcomes">Theoretical details - Count outcomes<a class="anchor" aria-label="anchor" href="#theoretical-details---count-outcomes"></a>
</h2>
<p>The CATE score represents an individual-level treatment effect
expressed as a rate ratio for count outcomes. It can be estimated with
boosting, Poisson regression, negative binomial regression, and the
doubly robust estimator two regressions <span class="citation">(Yadlowsky et al. 2020)</span> applied separately by
treatment group or with the other doubly robust estimator contrast
regression <span class="citation">(Yadlowsky et al. 2020)</span> applied
to the entire data set.</p>
<p>Assume that the following data are recorded for each of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
observations:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is a binary treatment taking value 0 or 1.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\boldsymbol{X}</annotation></semantics></math>
is a vector of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
baseline covariates.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is a count outcome.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is the exposure time during which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is recorded. It can vary across observations.</li>
</ul>
<p>The objective is to estimate the ratio-based CATE score defined
as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐗</mi><mo>=</mo><mi>𝐱</mi><mo>,</mo><mi>T</mi><mo>=</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐗</mi><mo>=</mo><mi>𝐱</mi><mo>,</mo><mi>T</mi><mo>=</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CATE(\boldsymbol{x})=\text{log}\left(\frac{\mathbb{E}[Y^{(1)}|\boldsymbol{X}=\boldsymbol{x},T=1]}{\mathbb{E}[Y^{(0)}|\boldsymbol{X}=\boldsymbol{x},T=1]}\right)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">Y^{(r)}</annotation></semantics></math>
is the potential outcome if the patient received the treatment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CATE(\boldsymbol{x})</annotation></semantics></math>
is interpreted as the individualized log-rate ratio of treatment 1 over
treatment 0 conditional on the baseline covariates.</p>
<p>The package offers 5 methods to estimate the CATE score: Poisson
regression, negative binomial regression, boosting, two regressions, and
contrast regression.</p>
<div class="section level3">
<h3 id="poisson">Poisson<a class="anchor" aria-label="anchor" href="#poisson"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Estimate the conditional mean outcome given baseline covariates
and log-transformed exposure time as the offset separately in each
treatment group (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐱</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>β</mi><mi>r</mi></msub><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\text{log}(\mathbb{E}[Y^{(r)}|\boldsymbol{x},t])=\beta_r \boldsymbol{\tilde x}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\tilde x}</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
with an intercept) with Poisson regression. Denote the prediction for
one time unit as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>r</mi></msub><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y^{(r)}(\boldsymbol{x},1)=\text{exp}(\hat \beta_r \boldsymbol{\tilde x})</annotation></semantics></math>.</p></li>
<li><p>The CATE score with Poisson is the plug-in estimator</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{CATE}_{Poisson}(\boldsymbol{x})=\text{log}\left(\frac{\hat Y^{(1)}(\boldsymbol{x},1)}{\hat Y^{(0)}(\boldsymbol{x},1)}\right)</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="negative-binomial">Negative binomial<a class="anchor" aria-label="anchor" href="#negative-binomial"></a>
</h3>
<p>Follow the same step as in Poisson but replace Poisson regression
with negative binomial regression in step 1.</p>
</div>
<div class="section level3">
<h3 id="boosting">Boosting<a class="anchor" aria-label="anchor" href="#boosting"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<p>Estimate the conditional mean outcome given baseline covariates
and log-transformed exposure time as the offset separately in each
treatment group (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐱</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y^{(r)}|\boldsymbol{x},t]</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>)
with Poisson-based gradient boosting regression method. Denote the
prediction for one time unit as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y^{(r)}(\boldsymbol{x},1)</annotation></semantics></math>.</p>
<ul>
<li>The base learners are regression trees with depth specified with the
argument <code>tree.depth</code> in <code><a href="../reference/catecvcount.html">catecvcount()</a></code> and
<code><a href="../reference/catefitcount.html">catefitcount()</a></code>. Default is 2.</li>
<li>The number of trees in boosting is selected via cross-validation
with a maximum number of trees specificed with the argument
<code>n.trees</code> in <code><a href="../reference/catecvcount.html">catecvcount()</a></code> and
<code><a href="../reference/catefitcount.html">catefitcount()</a></code>. Default is 200.</li>
</ul>
</li>
<li><p>The CATE score with boosting is the plug-in estimator</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>b</mi><mi>o</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{CATE}_{boosting}(\boldsymbol{x})=\text{log}\left(\frac{\hat Y^{(1)}(\boldsymbol{x},1)}{\hat Y^{(0)}(\boldsymbol{x},1)}\right)</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="two-regressions">Two regressions<a class="anchor" aria-label="anchor" href="#two-regressions"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Randomly separate the data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
(<code>Kfold</code>) non-overlapping parts of approximately equal sizes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>D</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">D_1, \dots, D_K</annotation></semantics></math>.</p></li>
<li>
<p>For each fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">k=1,\dots,K</annotation></semantics></math>,
and separately by treatment group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>:</p>
<p>2.1 Estimate the conditional mean outcome given baseline covariates
and log-transformed exposure time as the offset with the Poisson-based
gradient boosting regression method based on observations without the
kth fold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>,
and denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y_{-k}^{(r)}(\boldsymbol{x},t)</annotation></semantics></math>.
This is the initial nonparametric prediction of the potential
outcome.</p>
<p>2.2 Estimate the PS based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>.
Denote the estimated PS as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat \pi_{-k}(\boldsymbol{x})</annotation></semantics></math>
and estimate the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>W</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>r</mi><mfrac><mi>R</mi><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat W(r)=r\frac{R}{\hat \pi_{-k}(\boldsymbol{x})}+(1-r)\frac{(1-R)}{1-\hat \pi_{-k}(\boldsymbol{x})}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
denoting the treatment received.</p>
<p>2.3 Solve the following weighted estimating equation by fitting a
Poisson regression with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
as the response,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{log}(\hat Y^{(r)}(\boldsymbol{x},1))</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
as the covariates,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{log}(T)</annotation></semantics></math>
as the offset, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>W</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat W(r)</annotation></semantics></math>
as weight:</p>
<p><span class="math display">$$S(\alpha_{rk},
\boldsymbol{\gamma_{rk}})=\sum_{i \in D_{-k}} \hat W(r)
\pmatrix{\text{log}\left(\hat
Y^{(r)}(\boldsymbol{x},1)\right)\\\boldsymbol{\tilde x}}\left(Y -
\text{exp}\left(\alpha_{rk}\text{log}\left(\hat
Y^{(r)}(\boldsymbol{x},1)\right)+\boldsymbol{\gamma_{rk}^T\boldsymbol{\tilde
x}}\right)\times T\right)=0$$</span></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
denotes individual observations. Denote the roots by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>α</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mi>k</mi></mrow></msub><mo>,</mo><msub><mover><mi>𝛄</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\hat \alpha_{rk}, \boldsymbol{\hat\gamma_{rk}})</annotation></semantics></math>.</p>
</li>
<li><p>Solve the following doubly robust estimating equation by fitting
a Poisson regression with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>α</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mi>k</mi></mrow></msub><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><msubsup><mover><mi>𝛄</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{exp}\left(\hat\alpha_{rk}\text{log}\left(\hat Y^{(r)}(\boldsymbol{x},1)\right)+\boldsymbol{\hat\gamma_{rk}^T\boldsymbol{\tilde x}}\right)</annotation></semantics></math>
as the response,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\boldsymbol{x}</annotation></semantics></math>
as the covariates, and no offset or weight:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝛃</mi><mi>𝐫</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub></mrow></munder><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>α</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mi>k</mi></mrow></msub><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><msubsup><mover><mi>𝛄</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msubsup><mi>𝛃</mi><mi>𝐫</mi><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S(\boldsymbol{\beta_r})=\sum_{k=1}^K \sum_{i \in D_{-k}}\boldsymbol{\tilde x}\left(\text{exp}\left(\hat\alpha_{rk}\text{log}\left(\hat Y^{(r)}(\boldsymbol{x},1)\right)+\boldsymbol{\hat\gamma_{rk}^T\boldsymbol{\tilde x}}\right)-\text{exp}(\boldsymbol{\beta_r^T\tilde x})\right)=0</annotation></semantics></math>
Denote the estimator as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mi>𝐫</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_r}</annotation></semantics></math>.</p></li>
<li><p>Repeat steps 1-3 with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap samples and denote the estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐛</mi></mrow></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_{rb}}</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
sample. The final estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mi>𝐫</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_r}</annotation></semantics></math>
is the mean of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐛</mi></mrow></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_{rb}}</annotation></semantics></math>.</p></li>
<li><p>The CATE score with two regressions is</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mn>𝟏</mn></msub><mo>−</mo><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mn>𝟎</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\hat{CATE}_{tworeg}(\boldsymbol{x})=(\boldsymbol{\hat \beta_1} - \boldsymbol{\hat \beta_0})^T\boldsymbol{\tilde x}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="contrast-regression">Contrast regression<a class="anchor" aria-label="anchor" href="#contrast-regression"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Randomly separate the data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
(<code>Kfold</code>) non-overlapping parts of approximately equal sizes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>D</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">D_1, \dots, D_K</annotation></semantics></math>.</p></li>
<li>
<p>For each fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">k=1,\dots,K</annotation></semantics></math>,
and separately by treatment group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>:</p>
<p>2.1 Estimate the conditional mean outcome given baseline covariates
and log-transformed exposure time as the offset with the Poisson-based
gradient boosting regression method based on observations without the
kth fold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>,
and denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y_{-k}^{(r)}(\boldsymbol{x},t)</annotation></semantics></math>.
This is the initial nonparametric prediction of the potential
outcome.</p>
<p>2.2 Estimate the PS based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>.
Denote the estimated PS as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat \pi_{-k}(\boldsymbol{x})</annotation></semantics></math>.</p>
</li>
<li><p>Solve the following doubly robust estimating equation by
Newton-Raphson method or using a L2-norm score method if the former
fails to converge:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛅</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub></mrow></munder><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo minsize="3.0" maxsize="3.0" stretchy="false" form="prefix">[</mo><mfrac><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><mi>Y</mi><mi>T</mi></mfrac><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>+</mo><mfrac><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><mi>Y</mi><mi>T</mi></mfrac><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">]</mo><mo>=</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
S(\boldsymbol{\delta})&amp;=\sum_{k=1}^K \sum_{i \in D_{-k}} \boldsymbol{\tilde x}\Bigg[\frac{R\left\{\frac{Y}{T}-\frac{1}{2}\left(\hat Y_{-k}^{(0)}(\boldsymbol{ x})\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x}) + \hat Y_{-k}^{(1)}(\boldsymbol{x})\right)\right\}(1-\hat\pi_{-k}(\boldsymbol{x}))}{\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})+1-\hat\pi_{-k}(\boldsymbol{x})}\\
&amp;+\frac{(1-R)\left\{\frac{Y}{T}-\frac{1}{2}\left(\hat Y_{-k}^{(0)}(\boldsymbol{ x}) + \hat Y_{-k}^{(1)}(\boldsymbol{x})\text{exp}(-\boldsymbol{\delta^T}\boldsymbol{\tilde x})\right)\right\}\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})}{\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})+1-\hat\pi_{-k}(\boldsymbol{x})}\Bigg]=0
\end{aligned}</annotation></semantics></math> Denote the estimator as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\hat\delta}</annotation></semantics></math>.</p></li>
<li><p>Repeat steps 1-3 with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap samples and denote the estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐛</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \delta_b}</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
sample. The final estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\hat \delta}</annotation></semantics></math>
is the mean of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐛</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \delta_b}</annotation></semantics></math>.</p></li>
<li><p>The CATE score with contrast regression is</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><msup><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow></mrow><annotation encoding="application/x-tex">\hat{CATE}_{contrastreg}(\boldsymbol{x})=\boldsymbol{\hat \delta^T\tilde x}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="validation-curves-and-the-abc-statistics">Validation curves and the ABC statistics<a class="anchor" aria-label="anchor" href="#validation-curves-and-the-abc-statistics"></a>
</h3>
<p>The ABC statistic represents the area between the validation curve
and the ATE as described by <span class="citation">(Zhao et al.
2013)</span>. For a single CV iteration, it is implemented in the
training and validation sets separately as following:</p>
<p><strong>Step 1</strong>. Calculate the ATE in the training or
validation sets.</p>
<p><strong>Step 2</strong>. Calculate the ATE in 100 nested subgroups
based on the estimated CATE score and derive the corresponding
validation curve. Subgroups are defined with 100 equally-spaced
proportions from <code>min(prop.cutoff)</code> to
<code>max(prop.cutoff)</code> to ensure that enough data points are
available to build the validation curve.</p>
<p><strong>Step 3</strong>. The ABC is calculated with
<code><a href="../reference/auc.html">auc()</a></code> from <code>utility.R</code> using the natural cubic
spline interpolation, which calculates the area between the horizontal
line with y-intercept at the ATE calculated in <strong>step 1</strong>
over the range
[<code>min(prop.cutoff)</code>,<code>max(prop.cutoff)</code>]
(<em>y</em>) and the validation curve calculated in <strong>step
2</strong> (<em>x</em>).</p>
<p>The function <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> allows the user to combine
validation curves from 2 or more CV iterations (i.e.,
<code>cv.n &gt; 1</code>). There are 2 ways to combine the validation
curves:</p>
<ol style="list-style-type: decimal">
<li><p>The option <code>combine</code>=“median” takes the median of the
ATEs across all CV iterations in <strong>step 1</strong> and the median
of the ATEs in the 100 nested subgroups in <strong>step
2</strong>.</p></li>
<li><p>The option <code>combine</code>=“mean” takes the mean of the ATEs
across all CV iterations in <strong>step 1</strong> and the mean of the
ATEs in the 100 nested subgroups in <strong>step 2</strong>.</p></li>
</ol>
<p>In either case, the ABC calculations are carried out as in
<strong>step 3</strong> with the resulting <em>x</em> and
<em>y</em>.</p>
<p>The figure below explains how the ABC is calculated with a simple
schema. The ABC calculations are such that larger positive ABC values
always indicate more treatment effect heterogeneity. This is implemented
by considering separately the cases when larger or smaller outcomes are
preferred.</p>
<ul>
<li><p>If larger count outcomes are preferred
(<code>higher.y = TRUE</code>, e.g., positive events like number of
motor developmental milestones reached), a validation curve above the
ATE line and decreasing towards that line is synonym with treatment
effect heterogeneity (top left figure). However, sections of the
validation curve below the ATE line indicate inability to capture
treatment effect heterogeneity (bottom left figure). Hence, the ABC is
defined by subtracting the areas below the ATE line (red) from the areas
above the ATE line (green) such that larger positive ABC are
preferred.</p></li>
<li><p>If smaller count outcomes are preferred
(<code>higher.y = FALSE</code>, e.g., negative events like number of
relapses), a validation curve below the ATE line and increasing towards
that line is synonym with treatment effect heterogeneity (top right
figure). However, sections of the validation curve above the ATE line
indicate inability to capture treatment effect heterogeneity (bottom
right figure). Hence, the ABC is defined by subtracting the areas above
the ATE line (red) from the areas below the ATE line (green) such that
larger positive ABC are preferred.</p></li>
</ul>
<p><img src="ABCexample.png"><!-- --></p>
<p>ABC calculation examples in relation with <code>higher.y</code>
argument in <code><a href="../reference/catecv.html">catecv()</a></code> and <code><a href="../reference/catefit.html">catefit()</a></code>. Validation
curves are represented with a blue line and the dashed line is the
ATE</p>
</div>
</div>
<div class="section level2">
<h2 id="theoretical-details---survival-outcomes">Theoretical details - Survival outcomes<a class="anchor" aria-label="anchor" href="#theoretical-details---survival-outcomes"></a>
</h2>
<p>The CATE score represents an individual-level treatment effect for
survival data, estimated with random forest, boosting, Poisson
regression, and the doubly robust estimator (two regressions, <span class="citation">(Yadlowsky et al. 2020)</span>) applied separately by
treatment group or with the other doubly robust estimators (contrast
regression, <span class="citation">(Yadlowsky et al. 2020)</span>)
applied to the entire data set.</p>
<p>Assume that the following data are recorded for each of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
observations:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is a binary treatment taking value 0 or 1.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\boldsymbol{X}</annotation></semantics></math>
is a vector of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
baseline covariates.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is a survival time.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is a censoring time.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is the minimum between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
is an indicator taking value 1 if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">Y = T</annotation></semantics></math>
and 0 otherwise.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
is a truncation time for restricted mean time lost.</li>
</ul>
<p>The objective is to estimate the ratio-based CATE score defined
as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>τ</mi><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="prefix">|</mo><mi>𝐗</mi><mo>=</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>τ</mi><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="prefix">|</mo><mi>𝐗</mi><mo>=</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CATE(\boldsymbol{x})=\text{log}\left(\frac{\mathbb{E}[\tau - (T^{(1)} \wedge\tau)|\boldsymbol{X}=\boldsymbol{x}]}{\mathbb{E}[\tau - (T^{(0)} \wedge\tau)|\boldsymbol{X}=\boldsymbol{x}]}\right)</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">T^{(r)}</annotation></semantics></math>
is the potential survival time if the patient received the treatment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CATE(\boldsymbol{x})</annotation></semantics></math>
is interpreted as the individualized logarithm restricted mean time lost
(RMTL) ratio of treatment 1 over treatment 0 conditional on the baseline
covariates.</p>
<p>The package offers 5 methods to estimate the CATE score: Poisson
regression, random forest, boosting, two regressions, and contrast
regression.</p>
<div class="section level3">
<h3 id="poisson-1">Poisson<a class="anchor" aria-label="anchor" href="#poisson-1"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Estimate the conditional mean RMTL given baseline covariates
separately in each treatment group (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>τ</mi><mo>−</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="false" form="prefix">|</mo><mi>𝐱</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>β</mi><mi>r</mi></msub><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\text{log}(\mathbb{E}[\tau - T\wedge\tau|\boldsymbol{x}, r])=\beta_r \boldsymbol{\tilde x}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\tilde x}</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
with an intercept) with Poisson regression weighted with IPCW. Denote
the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>r</mi></msub><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y^{(r)}(\boldsymbol{x})=\text{exp}(\hat \beta_r \boldsymbol{\tilde x})</annotation></semantics></math>.</p></li>
<li><p>The CATE score with Poisson is the plug-in estimator</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>−</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{CATE}_{Poisson}(\boldsymbol{x})=\text{log}\left(\frac{\hat Y^{(1)}(\boldsymbol{x})}{\hat Y^{(0)}(\boldsymbol{x})}\right) = (\hat \beta_1 - \hat \beta_0) \boldsymbol{\tilde x}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="boosting-1">Boosting<a class="anchor" aria-label="anchor" href="#boosting-1"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<p>Estimate the conditional mean RMTL given baseline covariates
separately in each treatment group (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y^{(r)}|\boldsymbol{x}]</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>)
with Poisson-based gradient boosting regression method weighted with
IPCW. Denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y^{(r)}(\boldsymbol{x})</annotation></semantics></math>.</p>
<ul>
<li>The number of trees is specificed with the argument
<code>n.trees.boosting</code>. Default is 200.</li>
<li>The depth of trees is specified with the argument
<code>tree.depth</code>. Default is 2.</li>
</ul>
</li>
<li><p>The CATE score with boosting is the plug-in estimator</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>b</mi><mi>o</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{CATE}_{boosting}(\boldsymbol{x})=\text{log}\left(\frac{\hat Y^{(1)}(\boldsymbol{x})}{\hat Y^{(0)}(\boldsymbol{x})}\right)</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="random-forest">Random forest<a class="anchor" aria-label="anchor" href="#random-forest"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<p>Estimate the conditional mean RMTL given baseline covariates
separately in each treatment group (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y^{(r)}|\boldsymbol{x}]</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>)
with survival random forest. Denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y^{(r)}(\boldsymbol{x})</annotation></semantics></math>.</p>
<ul>
<li>The number of trees in boosting is selected via CV with a maximum
number of trees specificed with the argument <code>n.trees.rf</code>.
Default is 1,000.</li>
<li>The base learners are regression trees with depth specified with the
argument <code>tree.depth</code>. Default is 2.</li>
</ul>
</li>
<li><p>The CATE score with boosting is the plug-in estimator</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>b</mi><mi>o</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{CATE}_{boosting}(\boldsymbol{x})=\text{log}\left(\frac{\hat Y^{(1)}(\boldsymbol{x})}{\hat Y^{(0)}(\boldsymbol{x})}\right)</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="two-regressions-1">Two regressions<a class="anchor" aria-label="anchor" href="#two-regressions-1"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Randomly separate the data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
(<code>Kfold</code>) non-overlapping parts of approximately equal sizes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>D</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">D_1, \dots, D_K</annotation></semantics></math>.</p></li>
<li>
<p>For each fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">k=1,\dots,K</annotation></semantics></math>,
and separately by treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>:</p>
<p>2.1 Estimate the conditional mean RMTL given baseline covariates with
the Poisson-based gradient boosting regression method
(<code>initial.predictor.method = "boosting"</code>) based on
observations without the kth fold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>,
and denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y_{-k}^{(r)}(\boldsymbol{x})</annotation></semantics></math>.
This is the initial nonparametric prediction of the potential outcome.
Other methods can be used to generate an initial prediction (see
<code>initial.predictor.method</code> argument).</p>
<p>2.2 Estimate the propensity score model based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>.
Denote the estimated PS as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat \pi_{-k}(\boldsymbol{x})</annotation></semantics></math>
and estimate the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>W</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>r</mi><mfrac><mi>R</mi><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat W_{-k}(r)=r\frac{R}{\hat \pi_{-k}(\boldsymbol{x})}+(1-r)\frac{(1-R)}{1-\hat \pi_{-k}(\boldsymbol{x})}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
denoting the treatment received.</p>
<p>2.3 Estimate the IPCW:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>δ</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>I</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>≥</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mover><mi>K</mi><mo accent="true">̂</mo></mover><msup><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat L(r,y) = \frac{\delta+(1-\delta)I(y^{(r)}\geq\tau)}{\hat K_{C^{(r)}}(T \wedge \tau|x)}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>K</mi><mo accent="true">̂</mo></mover><msup><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat K_{C^{(r)}}(T \wedge \tau|x)</annotation></semantics></math>
is a consistent estimator of the survival function of the censoring time
given the covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>,
for example, using a Cox model and the Breslow estimator for the
cumulative baseline hazard function
(<code>ipcw.method = "breslow"</code>).</p>
<p>2.4 Solve the following weighted estimating equation by fitting a
Poisson regression with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tau - (T\wedge\tau)</annotation></semantics></math>
as the response,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{log}(\hat Y_{-k}^{(r)}(\boldsymbol{x}))</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
as the covariates, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>K</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><msub><mover><mi>W</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat K(r,y)\times\hat W_{-k}(r)</annotation></semantics></math>
as weight:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mi>r</mi><mi>k</mi></mrow></msub><mo>,</mo><msub><mi>𝛄</mi><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub></mrow></munder><mover><mi>K</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>W</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo>−</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mrow><mi>r</mi><mi>k</mi></mrow></msub><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>𝛄</mi><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S(\alpha_{rk}, \boldsymbol{\gamma_{rk}})=\sum_{i \in D_{-k}} \hat K(r,y) \hat W_{-k}(r) \left((\tau- T\wedge\tau) - \text{exp}\left(\alpha_{rk}\text{log}
 \left(\hat Y_{-k}^{(r)}(\boldsymbol{x})\right)+\boldsymbol{\gamma_{rk}^T}\boldsymbol{\tilde x}\right)\right)=0</annotation></semantics></math></p>
</li>
<li><p>Solve the following doubly robust estimating equation by fitting
a Poisson regression with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>α</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mi>k</mi></mrow></msub><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><msubsup><mover><mi>𝛄</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{exp}\left(\hat\alpha_{rk}\text{log}\left(\hat Y_{-k}^{(r)}(\boldsymbol{x})\right)+\boldsymbol{\hat\gamma_{rk}^T\boldsymbol{\tilde x}}\right)</annotation></semantics></math>
as the response,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\boldsymbol{x}</annotation></semantics></math>
as the covariates, and no offset or weight:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝛃</mi><mi>𝐫</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>D</mi><mi>k</mi></msub></mrow></munder><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>α</mi><mo accent="true">̂</mo></mover><mrow><mi>r</mi><mi>k</mi></mrow></msub><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><msubsup><mover><mi>𝛄</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐤</mi></mrow><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msubsup><mi>𝛃</mi><mi>𝐫</mi><mi>𝐓</mi></msubsup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S(\boldsymbol{\beta_r})=\sum_{k=1}^K \sum_{i \in D_{k}}\boldsymbol{\tilde x}\left(\text{exp}\left(\hat\alpha_{rk}\text{log}\left(\hat Y_{-k}^{(r)}(\boldsymbol{x})\right)+\boldsymbol{\hat\gamma_{rk}^T\boldsymbol{\tilde x}}\right)-\text{exp}(\boldsymbol{\beta_r^T\tilde x})\right)=0</annotation></semantics></math>
Denote the estimator as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mi>𝐫</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_r}</annotation></semantics></math>.</p></li>
<li><p>Repeat steps 1-3 with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap samples (<code>B</code>) and denote the estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐛</mi></mrow></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_{rb}}</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
sample. The final estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mi>𝐫</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_r}</annotation></semantics></math>
is the mean of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mrow><mi>𝐫</mi><mi>𝐛</mi></mrow></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \beta_{rb}}</annotation></semantics></math>.</p></li>
<li><p>The CATE score with two regression is</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mn>𝟏</mn></msub><mo>−</mo><msub><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mn>𝟎</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{CATE}_{tworeg}(\boldsymbol{x})=(\boldsymbol{\hat \beta_1} - \boldsymbol{\hat \beta_0})^T\boldsymbol{\tilde x}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="contrast-regression-1">Contrast regression<a class="anchor" aria-label="anchor" href="#contrast-regression-1"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Randomly separate the data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
(<code>Kfold</code>) non-overlapping parts of approximately equal sizes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>D</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">D_1, \dots, D_K</annotation></semantics></math>.</p></li>
<li>
<p>For each fold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">k=1,\dots,K</annotation></semantics></math>,
and separately by treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">r \in \{0,1\}</annotation></semantics></math>:</p>
<p>2.1 Estimate the conditional mean RMTL given baseline covariates with
the Poisson-based gradient boosting regression method
(<code>initial.predictor.method = "boosting"</code>) based on
observations without the kth fold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>,
and denote the prediction as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat Y_{-k}^{(r)}(\boldsymbol{x})</annotation></semantics></math>.
This is the initial nonparametric prediction of the potential outcome.
Other methods can be used to generate an initial prediction (see
<code>initial.predictor.method</code> argument).</p>
<p>2.2 Estimate the propensity score model based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mrow><mo>−</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">D_{-k}</annotation></semantics></math>.
Denote the estimated PS as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat \pi_{-k}(\boldsymbol{x})</annotation></semantics></math>.</p>
<p>2.3 Estimate the IPCW:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>δ</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>I</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>≥</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mover><mi>K</mi><mo accent="true">̂</mo></mover><msup><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat L(r,y) = \frac{\delta+(1-\delta)I(y^{(r)}\geq\tau)}{\hat K_{C^{(r)}}(T \wedge \tau|x)}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>K</mi><mo accent="true">̂</mo></mover><msup><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat K_{C^{(r)}}(T \wedge \tau|x)</annotation></semantics></math>
is a consistent estimator of the survival function of the censoring time
given the covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>,
for example, using a Cox model and the Breslow estimator for the
cumulative baseline hazard function
(<code>ipcw.method = "breslow"</code>).</p>
</li>
<li><p>Solve the following doubly robust estimating equation by
Newton-Raphson method or using a L2-norm score method if the former
fails to converge:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛅</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>D</mi><mi>k</mi></msub></mrow></munder><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo minsize="3.0" maxsize="3.0" stretchy="false" form="prefix">[</mo><mfrac><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo>−</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>−</mo><mfrac><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo>−</mo><mi>T</mi><mo>∧</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mtext mathvariant="normal">exp</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝛅</mi><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn><mo>−</mo><msub><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo>−</mo><mi>k</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">]</mo><mo>=</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
S(\boldsymbol{\delta})&amp;=\sum_{k=1}^K \sum_{i \in D_{k}} \hat L(r,y) \boldsymbol{\tilde x}\Bigg[\frac{R\left\{(\tau - T\wedge\tau)-\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat Y_{-k}^{(0)}(\boldsymbol{x})\right\}(1-\hat\pi_{-k}(\boldsymbol{x}))}{\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})+1-\hat\pi_{-k}(\boldsymbol{x})}\\
&amp;-\frac{(1-R)\left\{(\tau - T\wedge\tau)-\hat Y_{-k}^{(0)}(\boldsymbol{ x}) \right\}\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})}{\text{exp}(\boldsymbol{\delta^T}\boldsymbol{\tilde x})\hat\pi_{-k}(\boldsymbol{x})+1-\hat\pi_{-k}(\boldsymbol{x})}\Bigg]=0
\end{aligned}</annotation></semantics></math> Denote the estimator as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\hat\delta}</annotation></semantics></math>.</p></li>
<li><p>Repeat steps 1-3 with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap samples (<code>B</code>) and denote the estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐛</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \delta_b}</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
sample. The final estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\boldsymbol{\hat \delta}</annotation></semantics></math>
is the mean of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐛</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\hat \delta_b}</annotation></semantics></math>.</p></li>
<li><p>The CATE score with contrast regression is</p></li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mrow><mi>C</mi><mi>A</mi><mi>T</mi><mi>E</mi></mrow><mo accent="true">̂</mo></mover><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><msup><mover><mi>𝛅</mi><mo accent="true">̂</mo></mover><mi>𝐓</mi></msup><mover><mi>𝐱</mi><mo accent="true">̃</mo></mover></mrow></mrow><annotation encoding="application/x-tex">\widehat{CATE}_{contrastreg}(\boldsymbol{x})=\boldsymbol{\hat \delta^T\tilde x}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="validation-curves-and-the-abc-statistics-1">Validation curves and the ABC statistics<a class="anchor" aria-label="anchor" href="#validation-curves-and-the-abc-statistics-1"></a>
</h3>
<p>The ABC statistic represents the area between the validation curve
and the ATE as described by <span class="citation">(Zhao et al.
2013)</span>. For a single CV iteration and a certain CATE score method,
it is implemented as following in the training and validation sets
separately:</p>
<p><strong>Step 1</strong>. Calculate the ATE in the training or
validation sets.</p>
<p><strong>Step 2</strong>. Calculate the ATE in 100 nested subgroups
and derive the corresponding validation curve. Subgroups are defined
with 100 equally-spaced proportions from <code>min(prop.cutoff)</code>
to <code>max(prop.cutoff)</code> to ensure that enough data points are
available to build the validation curve.</p>
<p><strong>Step 3</strong>. The ABC is calculated with
<code><a href="../reference/auc.html">auc()</a></code> from <code>utility.R</code> using the natural cubic
spline interpolation, which calculates the area between the horizontal
line with y-intercept at the ATE calculated in <strong>step 1</strong>
(<em>y</em>) and the validation curve calculated in <strong>step
2</strong> (<em>x</em>) over the range [<code>min(prop.cutoff)</code>,
<code>max(prop.cutoff)</code>].</p>
<p>The function <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> allows the user combining validation
curves from 2 or more CV iterations (i.e., <code>cv.n &gt; 1</code>).
There are 2 ways to combine the validation curves:</p>
<ol style="list-style-type: decimal">
<li><p>The option <code>combine ="median"</code> takes the median of the
ATEs across all CV iterations in <strong>step 1</strong> and the median
of the ATEs in the 100 nested subgroups in <strong>step
2</strong>.</p></li>
<li><p>The option <code>combine ="mean"</code> takes the mean of the
ATEs across all CV iterations in <strong>step 1</strong> and the mean of
the ATEs in the 100 nested subgroups in <strong>step
2</strong>.</p></li>
</ol>
<p>In either case, the ABC calculations are carried out as in
<strong>step 3</strong> with the resulting <em>x</em> and
<em>y</em>.</p>
<p>The figure below explains how the ABC is calculated with a simple
schema. The ABC calculations are such that larger positive ABC values
always indicate more treatment effect heterogeneity. This is implemented
by considering separately the cases when larger or smaller outcomes are
preferred.</p>
<ul>
<li><p>If smaller survival outcomes are preferred
(<code>higher.y = FALSE</code>, e.g., time to a positive event like
recovery), a validation curve above the ATE line which decreases towards
it is synonym with treatment effect heterogeneity (top left figure).
However, sections of the validation curve below the ATE line indicate
inability to capture treatment effect heterogeneity (bottom left
figure). Hence, the ABC is defined by subtracting the areas below the
ATE line from the areas above the ATE line such that larger positive ABC
are preferred.</p></li>
<li><p>If larger survival outcomes are preferred
(<code>higher.y = TRUE</code>, e.g., time to a negative event like
symptom onset), a validation curve (in blue) below the ATE line (dashed)
which increases towards it is synonym with treatment effect
heterogeneity (top right figure). However, sections of the validation
curve above the ATE line indicate inability to capture treatment effect
heterogeneity (bottom right figure). Hence, the ABC is defined by
subtracting the areas above the ATE line (in red) from the areas below
the ATE line (in green) such that larger positive ABC are
preferred.</p></li>
</ul>
<p><img src="ABCexample_survival.png"><!-- --></p>
<p>ABC calculation examples in relation with <code>higher.y</code>
argument in <code><a href="../reference/catecv.html">catecv()</a></code> and <code><a href="../reference/catefit.html">catefit()</a></code>. Validation
curves are represented with a blue line and the dashed line is the
ATE.</p>
</div>
</div>
<div class="section level2">
<h2 id="other-precmed-vignettes-in-this-serie">Other <code>precmed</code> vignettes in this serie<a class="anchor" aria-label="anchor" href="#other-precmed-vignettes-in-this-serie"></a>
</h2>
<p><a href="Count-examples.html">1. Examples for count outcome</a><br><a href="Survival-examples.html">2. Examples for survival
outcome</a><br><a href="Additional-examples.html">3. Additional examples</a><br><a href="Theoretical-details.html">4. Theoretical details</a></p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-yadlowsky2020estimation" class="csl-entry">
Yadlowsky, Steve, Fabio Pellegrini, Federica Lionetto, Stefan Braune,
and Lu Tian. 2020. <span>“Estimation and Validation of Ratio-Based
Conditional Average Treatment Effects Using Observational Data.”</span>
<em>Journal of the American Statistical Association</em>, 1–18.
</div>
<div id="ref-zhao2013effectively" class="csl-entry">
Zhao, Lihui, Lu Tian, Tianxi Cai, Brian Claggett, and Lee-Jen Wei. 2013.
<span>“Effectively Selecting a Target Population for a Future
Comparative Study.”</span> <em>Journal of the American Statistical
Association</em> 108 (502): 527–39.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Lu Tian, Xiaotong Jiang, Gabrielle Simoneau, Thomas Debray.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
